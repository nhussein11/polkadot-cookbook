name: Create Zero to Hero Release
description: "Test Zero to Hero code, generate Zero to Hero scripts, and publish a release"

run-name: "Zero to Hero"

env:
  PARACHAIN_REPO: "https://github.com/polkadot-developers/polkadot-docs-tests/"
  PARACHAIN_BRANCH: ${{ github.ref_name }}
  PARA_ID: "1000"
  RELAY_CHAIN: "paseo"

on:
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a release after generating scripts'
        required: false
        default: 'false'
        type: boolean
      force_generation:
        description: 'Force script generation even if no version changes detected'
        required: false
        default: 'false'
        type: boolean
  push:
    branches: [ master, dev ]
    paths:
      - '.github/versions.yml'
  pull_request:
    branches: [ master, dev ]
    paths:
      - '.github/versions.yml'

jobs:
  # Check if zero_to_hero versions have changed
  check-version-changes:
    name: Check Version Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
      changed-versions: ${{ steps.check-changes.outputs.changed-versions }}
    steps:
      - name: Checkout current commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check for zero_to_hero version changes
        id: check-changes
        run: |
          echo "$(date -Iseconds) üîç Checking for zero_to_hero version changes..."
          
          DEPS_FILE=".github/versions.yml"
          TUTORIAL="zero_to_hero"
          HAS_CHANGES="false"
          CHANGED_VERSIONS=""
          
          # Validate that config file exists
          if [ ! -f "$DEPS_FILE" ]; then
            echo "‚ùå Dependencies file not found: $DEPS_FILE"
            exit 1
          fi
          
          # Function to get version (tutorial-specific first, then global)
          get_version() {
            local dep="$1"
            local version
            
            # Try tutorial-specific version first
            version=$(yq eval ".${TUTORIAL}.${dep}" "$DEPS_FILE" 2>/dev/null)
            if [ "$version" = "null" ] || [ -z "$version" ]; then
              # Fallback to global version
              version=$(yq eval ".versions.${dep}" "$DEPS_FILE" 2>/dev/null)
            fi
            
            echo "$version"
          }
          
          # Get current versions
          CURRENT_RUST=$(get_version "rust")
          CURRENT_CHAIN_SPEC=$(get_version "chain_spec_builder") 
          CURRENT_OMNI_NODE=$(get_version "polkadot_omni_node")
          
          echo "üìã Current versions:"
          echo "  - rust: $CURRENT_RUST"
          echo "  - chain_spec_builder: $CURRENT_CHAIN_SPEC"
          echo "  - polkadot_omni_node: $CURRENT_OMNI_NODE"
          
          # Check for manual force generation
          if [ "${{ github.event.inputs.force_generation }}" = "true" ]; then
            echo "üîÑ Force generation enabled - proceeding with script generation"
            HAS_CHANGES="true"
            CHANGED_VERSIONS="forced generation"
          # For workflow_dispatch, always proceed unless explicitly forced
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "üîÑ Manual trigger detected - proceeding with script generation"
            HAS_CHANGES="true"
            CHANGED_VERSIONS="manual trigger"
          else
            # For push/PR events, check what changed
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            else
              # For push events, compare with previous commit
              BASE_SHA="${{ github.event.before }}"
            fi
            
            echo "üîç Comparing with base commit: $BASE_SHA"
            
            # Check if we have a valid base SHA and it exists
            if [ "$BASE_SHA" != "0000000000000000000000000000000000000000" ] && git cat-file -e "$BASE_SHA" 2>/dev/null; then
              # Get previous versions if the file existed
              if git cat-file -e "$BASE_SHA:$DEPS_FILE" 2>/dev/null; then
                echo "üìã Getting previous versions from $BASE_SHA..."
                
                # Create temporary file with previous versions
                git show "$BASE_SHA:$DEPS_FILE" > previous_versions.yml
                
                # Function to get version from previous file
                get_previous_version() {
                  local dep="$1"
                  local version
                  
                  # Try tutorial-specific version first
                  version=$(yq eval ".${TUTORIAL}.${dep}" previous_versions.yml 2>/dev/null)
                  if [ "$version" = "null" ] || [ -z "$version" ]; then
                    # Fallback to global version
                    version=$(yq eval ".versions.${dep}" previous_versions.yml 2>/dev/null)
                  fi
                  
                  echo "$version"
                }
                
                PREVIOUS_RUST=$(get_previous_version "rust")
                PREVIOUS_CHAIN_SPEC=$(get_previous_version "chain_spec_builder")
                PREVIOUS_OMNI_NODE=$(get_previous_version "polkadot_omni_node")
                
                echo "üìã Previous versions:"
                echo "  - rust: $PREVIOUS_RUST"
                echo "  - chain_spec_builder: $PREVIOUS_CHAIN_SPEC"  
                echo "  - polkadot_omni_node: $PREVIOUS_OMNI_NODE"
                
                # Compare versions
                CHANGES_FOUND=""
                
                if [ "$CURRENT_RUST" != "$PREVIOUS_RUST" ]; then
                  echo "üîÑ Rust version changed: $PREVIOUS_RUST ‚Üí $CURRENT_RUST"
                  CHANGES_FOUND="$CHANGES_FOUND rust($PREVIOUS_RUST‚Üí$CURRENT_RUST)"
                fi
                
                if [ "$CURRENT_CHAIN_SPEC" != "$PREVIOUS_CHAIN_SPEC" ]; then
                  echo "üîÑ Chain spec builder version changed: $PREVIOUS_CHAIN_SPEC ‚Üí $CURRENT_CHAIN_SPEC"
                  CHANGES_FOUND="$CHANGES_FOUND chain_spec_builder($PREVIOUS_CHAIN_SPEC‚Üí$CURRENT_CHAIN_SPEC)"
                fi
                
                if [ "$CURRENT_OMNI_NODE" != "$PREVIOUS_OMNI_NODE" ]; then
                  echo "üîÑ Omni node version changed: $PREVIOUS_OMNI_NODE ‚Üí $CURRENT_OMNI_NODE"
                  CHANGES_FOUND="$CHANGES_FOUND polkadot_omni_node($PREVIOUS_OMNI_NODE‚Üí$CURRENT_OMNI_NODE)"
                fi
                
                if [ -n "$CHANGES_FOUND" ]; then
                  HAS_CHANGES="true"
                  CHANGED_VERSIONS="$CHANGES_FOUND"
                  echo "‚úÖ Zero to Hero version changes detected!"
                else
                  echo "‚ÑπÔ∏è No zero_to_hero version changes detected"
                fi
                
                # Cleanup
                rm -f previous_versions.yml
              else
                echo "üìù Previous versions.yml not found - treating as new file"
                HAS_CHANGES="true"
                CHANGED_VERSIONS="new versions file"
              fi
            else
              echo "‚ö†Ô∏è Cannot compare versions (invalid or missing base commit) - proceeding with generation"
              HAS_CHANGES="true"
              CHANGED_VERSIONS="unable to compare"
            fi
          fi
          
          echo "has-changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "changed-versions=$CHANGED_VERSIONS" >> $GITHUB_OUTPUT
          
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "$(date -Iseconds) ‚úÖ Proceeding with script generation"
            echo "üìã Changes detected: $CHANGED_VERSIONS"
          else
            echo "$(date -Iseconds) ‚è≠Ô∏è Skipping script generation (no version changes)"
          fi

  # First, run the existing parachain build workflow
  build-parachain:
    name: Build Parachain
    needs: check-version-changes
    if: needs.check-version-changes.outputs.has-changes == 'true'
    uses: ./.github/workflows/build-kitchensink-parachain.yml
    secrets: inherit

  # Generate setup scripts after successful build
  generate-scripts:
    name: Generate Scripts for Zero to Hero tutorial
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain]
    if: always() && needs.check-version-changes.outputs.has-changes == 'true' && needs.build-parachain.result == 'success'
    outputs:
      rust-version: ${{ steps.resolve-versions.outputs.rust-version }}
      chain-spec-builder-version: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
      omni-node-version: ${{ steps.resolve-versions.outputs.omni-node-version }}
      scripts-committed: ${{ steps.commit-scripts.outputs.scripts-committed }}
      commit-sha: ${{ steps.commit-scripts.outputs.commit-sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Fetch full history for proper git operations
          fetch-depth: 0
          # Use a token that can push to protected branches
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read versions from versions.yml
        id: resolve-versions
        run: |
          # Install yq for YAML parsing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          DEPS_FILE=".github/versions.yml"
          TUTORIAL="zero_to_hero"
          
          # Validate that config file exists
          if [ ! -f "$DEPS_FILE" ]; then
            echo "‚ùå Dependencies file not found: $DEPS_FILE"
            exit 1
          fi
          
          # Function to get version (tutorial-specific first, then global)
          get_version() {
            local dep="$1"
            local version
            
            # Try tutorial-specific version first
            version=$(yq eval ".${TUTORIAL}.${dep}" "$DEPS_FILE" 2>/dev/null)
            if [ "$version" = "null" ] || [ -z "$version" ]; then
              # Fallback to global version
              version=$(yq eval ".versions.${dep}" "$DEPS_FILE" 2>/dev/null)
            fi
            
            echo "$version"
          }
          
          # Get versions from config file
          CHAIN_SPEC_VERSION=$(get_version "chain_spec_builder")
          OMNI_NODE_VERSION=$(get_version "polkadot_omni_node")
          RUST_VERSION=$(get_version "rust")
          
          # Validate all versions were resolved
          if [ -z "$CHAIN_SPEC_VERSION" ] || [ "$CHAIN_SPEC_VERSION" = "null" ]; then
            echo "‚ùå chain-spec-builder version not resolved"
            exit 1
          fi
          
          if [ -z "$OMNI_NODE_VERSION" ] || [ "$OMNI_NODE_VERSION" = "null" ]; then
            echo "‚ùå omni-node version not resolved"
            exit 1
          fi
          
          if [ -z "$RUST_VERSION" ] || [ "$RUST_VERSION" = "null" ]; then
            echo "‚ùå rust version not resolved"
            exit 1
          fi
          
          echo "chain-spec-builder-version=$CHAIN_SPEC_VERSION" >> $GITHUB_OUTPUT
          echo "omni-node-version=$OMNI_NODE_VERSION" >> $GITHUB_OUTPUT
          echo "rust-version=$RUST_VERSION" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) üìã Resolved versions for scripts:"
          echo "  - chain-spec-builder: $CHAIN_SPEC_VERSION"
          echo "  - omni-node: $OMNI_NODE_VERSION" 
          echo "  - rust: $RUST_VERSION"
          echo "üîÑ Triggered by: ${{ needs.check-version-changes.outputs.changed-versions }}"

      - name: Create scripts directory
        run: |
          echo "$(date -Iseconds) üìÅ Creating scripts directory..."
          mkdir -p scripts/zero-to-hero
          echo "‚úÖ Scripts directory created"

      - name: Generate Rust setup script
        run: |
          echo "$(date -Iseconds) ü¶Ä Generating Rust setup script..."
          cat > scripts/zero-to-hero/setup-rust.sh << 'EOF'
          #!/bin/bash
          # Rust Setup Script
          # This script sets up Rust with the required version and components
          
          set -e
          
          RUST_VERSION="${{ steps.resolve-versions.outputs.rust-version }}"
          
          echo "ü¶Ä Setting up Rust $RUST_VERSION..."
          echo "üì¶ Installing Rust toolchain and components..."
          
          # Set default Rust version
          rustup default $RUST_VERSION
          
          # Add WASM target for the current platform
          rustup target add wasm32-unknown-unknown --toolchain $RUST_VERSION
          
          # Add rust source for the current platform  
          rustup component add rust-src --toolchain $RUST_VERSION
          
          echo "‚úÖ Rust setup completed successfully!"
          echo "üìã Installed components:"
          echo "  - Rust toolchain: $RUST_VERSION"
          echo "  - WASM target: wasm32-unknown-unknown"
          echo "  - Rust source component"
          
          # Verify installation
          echo "üîç Verifying installation..."
          rustup show
          EOF
          
          chmod +x scripts/zero-to-hero/setup-rust.sh
          echo "‚úÖ Rust setup script created: scripts/zero-to-hero/setup-rust.sh"

      - name: Generate chain-spec-builder setup script
        run: |
          echo "$(date -Iseconds) üîß Generating chain-spec-builder setup script..."
          cat > scripts/zero-to-hero/install-chain-spec-builder.sh << 'EOF'
          #!/bin/bash
          # Chain Spec Builder Installation Script
          # This script installs the staging-chain-spec-builder tool
          
          set -e
          
          CHAIN_SPEC_VERSION="${{ steps.resolve-versions.outputs.chain-spec-builder-version }}"
          
          echo "üîß Installing staging-chain-spec-builder $CHAIN_SPEC_VERSION..."
          
          # Install chain-spec-builder with locked dependencies
          cargo install --locked staging-chain-spec-builder@$CHAIN_SPEC_VERSION
          
          echo "‚úÖ Chain spec builder installation completed!"
          echo "üìã Installed version: $CHAIN_SPEC_VERSION"
          
          # Verify installation
          echo "üîç Verifying installation..."
          chain-spec-builder --version
          EOF
          
          chmod +x scripts/zero-to-hero/install-chain-spec-builder.sh
          echo "‚úÖ Chain spec builder script created: scripts/zero-to-hero/install-chain-spec-builder.sh"

      - name: Generate omni-node setup script
        run: |
          echo "$(date -Iseconds) üöÄ Generating omni-node setup script..."
          cat > scripts/zero-to-hero/install-omni-node.sh << 'EOF'
          #!/bin/bash
          # Omni Node Installation Script  
          # This script installs the polkadot-omni-node
          
          set -e
          
          OMNI_NODE_VERSION="${{ steps.resolve-versions.outputs.omni-node-version }}"
          
          echo "üöÄ Installing polkadot-omni-node $OMNI_NODE_VERSION..."
          
          # Install omni-node with locked dependencies
          cargo install --locked polkadot-omni-node@$OMNI_NODE_VERSION
          
          echo "‚úÖ Omni node installation completed!"
          echo "üìã Installed version: $OMNI_NODE_VERSION"
          
          # Verify installation
          echo "üîç Verifying installation..."
          polkadot-omni-node --version
          EOF
          
          chmod +x scripts/zero-to-hero/install-omni-node.sh  
          echo "‚úÖ Omni node script created: scripts/zero-to-hero/install-omni-node.sh"

      - name: Generate chain spec creation script
        run: |
          echo "$(date -Iseconds) ‚õìÔ∏è Generating chain spec creation script..."
          cat > scripts/zero-to-hero/generate-chain-spec.sh << 'EOF'
          #!/bin/bash
          # Chain Specification Generation Script
          # This script generates a development chain specification for the parachain
          
          set -e
          
          PARA_ID="${{ env.PARA_ID }}"
          RELAY_CHAIN="${{ env.RELAY_CHAIN }}"
          RUNTIME_PATH="./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm"
          
          echo "‚õìÔ∏è Generating chain specification..."
          echo "üìã Configuration:"
          echo "  - Para ID: $PARA_ID"
          echo "  - Relay Chain: $RELAY_CHAIN"
          echo "  - Runtime: $RUNTIME_PATH"
          
          # Check if runtime exists
          if [ ! -f "$RUNTIME_PATH" ]; then
            echo "‚ùå Runtime WASM file not found: $RUNTIME_PATH"
            echo "üí° Make sure you have built the parachain runtime first"
            echo "üí° Try running: cargo build --release"
            exit 1
          fi
          
          # Generate chain specification
          chain-spec-builder create \
            -t development \
            --relay-chain $RELAY_CHAIN \
            --para-id $PARA_ID \
            --runtime $RUNTIME_PATH \
            named-preset development
          
          # Verify chain spec was created
          if [ ! -f "chain_spec.json" ]; then
            echo "‚ùå Chain specification generation failed"
            exit 1
          fi
          
          echo "‚úÖ Chain specification generated successfully!"
          echo "üìÑ Output file: chain_spec.json"
          echo "üìä File size: $(du -h chain_spec.json | cut -f1)"
          
          # Validate JSON
          if command -v jq >/dev/null 2>&1; then
            echo "üîç Validating JSON structure..."
            if jq empty chain_spec.json; then
              echo "‚úÖ Chain specification is valid JSON"
              
              # Extract key information
              CHAIN_NAME=$(jq -r '.name // "unknown"' chain_spec.json)
              echo "üìã Chain Name: $CHAIN_NAME"
            else
              echo "‚ö†Ô∏è Chain specification may have JSON formatting issues"
            fi
          fi
          EOF
          
          chmod +x scripts/zero-to-hero/generate-chain-spec.sh
          echo "‚úÖ Chain spec generation script created: scripts/zero-to-hero/generate-chain-spec.sh"

      - name: Generate node startup script
        run: |
          echo "$(date -Iseconds) üñ•Ô∏è Generating node startup script..."
          cat > scripts/zero-to-hero/start-node.sh << 'EOF'
          #!/bin/bash
          # Parachain Node Startup Script
          # This script starts the parachain node in development mode
          
          set -e
          
          CHAIN_SPEC="./chain_spec.json"
          
          echo "üñ•Ô∏è Starting parachain node..."
          echo "üìã Configuration:"
          echo "  - Chain spec: $CHAIN_SPEC"
          echo "  - Mode: Development"
          echo "  - RPC: All CORS enabled, unsafe methods allowed"
          
          # Check if chain spec exists
          if [ ! -f "$CHAIN_SPEC" ]; then
            echo "‚ùå Chain specification not found: $CHAIN_SPEC"
            echo "üí° Generate it first by running: ./scripts/zero-to-hero/generate-chain-spec.sh"
            exit 1
          fi
          
          echo "üöÄ Starting polkadot-omni-node..."
          echo "üì° RPC will be available at: http://localhost:9944"
          echo "üîç Press Ctrl+C to stop the node"
          echo ""
          
          # Start the node
          polkadot-omni-node \
            --chain $CHAIN_SPEC \
            --dev \
            --rpc-cors all \
            --rpc-methods unsafe
          EOF
          
          chmod +x scripts/zero-to-hero/start-node.sh
          echo "‚úÖ Node startup script created: scripts/zero-to-hero/start-node.sh"

      - name: Generate setup instructions
        run: |
          echo "$(date -Iseconds) üìñ Generating setup instructions..."
          cat > scripts/zero-to-hero/README.md << 'EOF'
          # Parachain Development Scripts
          
          This directory contains scripts to set up and run a local parachain development environment.
          
          ## Generated Configuration
          
          These scripts were generated automatically with the following versions:
          - **Rust**: `${{ steps.resolve-versions.outputs.rust-version }}`
          - **Chain Spec Builder**: `${{ steps.resolve-versions.outputs.chain-spec-builder-version }}`
          - **Omni Node**: `${{ steps.resolve-versions.outputs.omni-node-version }}`
          - **Para ID**: `${{ env.PARA_ID }}`
          - **Relay Chain**: `${{ env.RELAY_CHAIN }}`
          
          **Version Changes**: ${{ needs.check-version-changes.outputs.changed-versions }}
          
          ## Quick Start
          
          1. **Setup Rust toolchain:**
             ```bash
             ./scripts/zero-to-hero/setup-rust.sh
             ```
          
          2. **Install chain-spec-builder:**
             ```bash
             ./scripts/zero-to-hero/install-chain-spec-builder.sh
             ```
          
          3. **Install omni-node:**
             ```bash
             ./scripts/zero-to-hero/install-omni-node.sh
             ```
          
          4. **Build your parachain runtime** (if not already done):
             ```bash
             cargo build --release
             ```
          
          5. **Generate chain specification:**
             ```bash
             ./scripts/zero-to-hero/generate-chain-spec.sh
             ```
          
          6. **Start the parachain node:**
             ```bash
             ./scripts/zero-to-hero/start-node.sh
             ```
          
          ## Script Details
          
          ### `setup-rust.sh`
          Sets up the Rust toolchain with the required version and adds WASM compilation support.
          
          ### `install-chain-spec-builder.sh`
          Installs the staging-chain-spec-builder tool for generating chain specifications.
          
          ### `install-omni-node.sh`
          Installs the polkadot-omni-node for running the parachain.
          
          ### `generate-chain-spec.sh`
          Creates a development chain specification file (`chain_spec.json`) for your parachain.
          
          ### `start-node.sh`
          Starts the parachain node in development mode with RPC endpoints enabled.
          
          ## RPC Endpoints
          
          Once the node is running, you can access:
          - **HTTP RPC**: `http://localhost:9944`
          - **WebSocket RPC**: `ws://localhost:9944`
          
          ## Repository Information
          
          - **Source**: `${{ env.PARACHAIN_REPO }}`
          - **Branch**: `${{ env.PARACHAIN_BRANCH }}`
          - **Generated**: $(date -Iseconds)
          - **Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Commit**: ${{ github.sha }}
          EOF
          
          echo "‚úÖ Setup instructions created: scripts/zero-to-hero/README.md"

      - name: Validate generated scripts
        run: |
          echo "$(date -Iseconds) üîç Validating generated scripts..."
          
          # Check that all scripts exist and are executable
          SCRIPTS=(
            "setup-rust.sh"
            "install-chain-spec-builder.sh" 
            "install-omni-node.sh"
            "generate-chain-spec.sh"
            "start-node.sh"
          )
          
          for script in "${SCRIPTS[@]}"; do
            SCRIPT_PATH="scripts/zero-to-hero/$script"
            if [ -f "$SCRIPT_PATH" ] && [ -x "$SCRIPT_PATH" ]; then
              echo "‚úÖ $script - exists and executable"
              echo "   üìä Size: $(du -h "$SCRIPT_PATH" | cut -f1)"
            else
              echo "‚ùå $script - missing or not executable"
              exit 1
            fi
          done
          
          # Validate README exists
          if [ -f "scripts/zero-to-hero/README.md" ]; then
            echo "‚úÖ README.md - exists"
            echo "   üìä Size: $(du -h scripts/zero-to-hero/README.md | cut -f1)"
          else
            echo "‚ùå README.md - missing"
            exit 1
          fi
          
          echo "$(date -Iseconds) ‚úÖ All scripts validated successfully"

      - name: Commit generated scripts to repository
        id: commit-scripts
        run: |
          echo "$(date -Iseconds) üíæ Committing generated scripts to repository..."
          
          # Configure git with bot credentials
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add the scripts directory
          git add scripts/zero-to-hero/
          
          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No changes to commit - scripts are up to date"
            echo "scripts-committed=false" >> $GITHUB_OUTPUT
            echo "commit-sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          else
            # Create a comprehensive commit message
            COMMIT_MSG="ü§ñ Update zero-to-hero setup scripts

          Version changes: ${{ needs.check-version-changes.outputs.changed-versions }}
          
          Updated component versions:
          - Rust: ${{ steps.resolve-versions.outputs.rust-version }}
          - Chain Spec Builder: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
          - Omni Node: ${{ steps.resolve-versions.outputs.omni-node-version }}
          
          Scripts updated:
          - setup-rust.sh
          - install-chain-spec-builder.sh
          - install-omni-node.sh
          - generate-chain-spec.sh
          - start-node.sh
          - README.md
          
          Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            
            # Commit the changes
            git commit -m "$COMMIT_MSG"
            
            # Get the commit SHA after committing
            COMMIT_SHA=$(git rev-parse HEAD)
            
            # Push the changes
            echo "üì§ Pushing changes to ${{ github.ref_name }}..."
            git push origin ${{ github.ref_name }}
            
            echo "‚úÖ Scripts committed and pushed to repository"
            echo "üìã Commit: $COMMIT_SHA"
            echo "üîó View: ${{ github.server_url }}/${{ github.repository }}/commit/$COMMIT_SHA"
            
            echo "scripts-committed=true" >> $GITHUB_OUTPUT
            echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          fi

      - name: Upload generated scripts as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: parachain-setup-scripts-${{ github.run_id }}
          path: scripts/zero-to-hero/
          retention-days: 30

      - name: Create scripts archive
        run: |
          echo "$(date -Iseconds) üì¶ Creating scripts archive..."
          tar -czf parachain-zero-to-hero-scripts.tar.gz scripts/zero-to-hero/
          echo "‚úÖ Archive created: parachain-zero-to-hero-scripts.tar.gz"
          echo "üìä Archive size: $(du -h parachain-zero-to-hero-scripts.tar.gz | cut -f1)"

      - name: Upload scripts archive as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: parachain-zero-to-hero-scripts-archive-${{ github.run_id }}
          path: parachain-zero-to-hero-scripts.tar.gz
          retention-days: 30

  create-release:
    name: Create Release with Scripts
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts]
    if: |
      always() && 
      needs.check-version-changes.outputs.has-changes == 'true' && 
      needs.generate-scripts.result == 'success' &&
      needs.generate-scripts.outputs.scripts-committed == 'true' &&
      (
        (github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/dev')) ||
        github.event.inputs.create_release == 'true'
      )
    permissions:
      contents: write
      actions: read
      pull-requests: read
    outputs:
      release-tag: ${{ steps.create-tag.outputs.tag }}
      release-url: ${{ steps.create-release.outputs.html_url }}
    steps:
      - name: Checkout at scripts commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ needs.generate-scripts.outputs.commit-sha }}

      - name: Verify scripts are present
        run: |
          echo "$(date -Iseconds) üîç Verifying scripts are present..."
          
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          CURRENT_SHA=$(git rev-parse HEAD)
          
          echo "üìã Expected commit: $SCRIPTS_COMMIT_SHA"
          echo "üìã Current commit: $CURRENT_SHA"
          
          if [ "$CURRENT_SHA" != "$SCRIPTS_COMMIT_SHA" ]; then
            echo "‚ùå Not at expected commit! Fetching latest..."
            git fetch origin
            git checkout $SCRIPTS_COMMIT_SHA
            CURRENT_SHA=$(git rev-parse HEAD)
            echo "üìã Updated to: $CURRENT_SHA"
          fi
          
          # Verify scripts directory exists
          if [ -d "scripts/zero-to-hero" ]; then
            echo "‚úÖ Scripts directory found"
            echo "üìã Scripts available:"
            ls -la scripts/zero-to-hero/
          else
            echo "‚ùå Scripts directory not found at commit $CURRENT_SHA!"
            echo "üîç Repository contents:"
            ls -la
            exit 1
          fi

      - name: Determine version bump
        id: version-bump
        run: |
          echo "$(date -Iseconds) üîç Determining version bump..."
          
          # Get the latest tag, default to v0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "üìã Latest tag: $LATEST_TAG"
          
          # Extract version components (remove 'v' prefix)
          VERSION=${LATEST_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0} 
          PATCH=${VERSION_PARTS[2]:-0}
          
          echo "üìã Current version: $MAJOR.$MINOR.$PATCH"
          
          # Analyze commits since last tag to determine bump type
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS_SINCE=""
          else
            COMMITS_SINCE=$(git log $LATEST_TAG..HEAD --oneline)
          fi
          
          # Determine bump type based on commit messages and branch
          BUMP_TYPE="patch"  # Default to patch
          
          # Check for breaking changes (major bump)
          if echo "$COMMITS_SINCE" | grep -i -E "(breaking|major|BREAKING CHANGE)" > /dev/null; then
            BUMP_TYPE="major"
          # Check for new features (minor bump)
          elif echo "$COMMITS_SINCE" | grep -i -E "(feat|feature|add|new)" > /dev/null; then
            BUMP_TYPE="minor"
          # Check if we're on dev branch (pre-release)
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            BUMP_TYPE="prerelease"
          fi
          
          # Apply version bump
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            prerelease)
              # For pre-release, increment patch and add pre-release identifier
              PATCH=$((PATCH + 1))
              PRE_RELEASE="dev.$(date +%Y%m%d%H%M%S)"
              ;;
          esac
          
          # Construct new version
          if [ "$BUMP_TYPE" = "prerelease" ]; then
            NEW_VERSION="$MAJOR.$MINOR.$PATCH-$PRE_RELEASE"
          else
            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          fi
          
          echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "previous-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) ‚úÖ Version bump determined:"
          echo "  - Type: $BUMP_TYPE"
          echo "  - Previous: $LATEST_TAG"
          echo "  - New: v$NEW_VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          echo "$(date -Iseconds) üìù Generating changelog..."
          
          NEW_VERSION="${{ steps.version-bump.outputs.new-version }}"
          PREVIOUS_TAG="${{ steps.version-bump.outputs.previous-tag }}"
          RUST_VERSION="${{ needs.generate-scripts.outputs.rust-version }}"
          CHAIN_SPEC_VERSION="${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
          OMNI_NODE_VERSION="${{ needs.generate-scripts.outputs.omni-node-version }}"
          CHANGED_VERSIONS="${{ needs.check-version-changes.outputs.changed-versions }}"
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          
          # Create changelog file
          CHANGELOG_FILE="RELEASE_CHANGELOG.md"
          
          cat > $CHANGELOG_FILE << EOF
          # Release v$NEW_VERSION
          
          Released: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## üéØ What's New
          
          This release includes automatically generated setup scripts for local parachain development with updated component versions.
          
          ### üîÑ Version Changes
          **Triggered by**: $CHANGED_VERSIONS
          
          ### üì¶ Component Versions
          - **Rust Toolchain**: \`$RUST_VERSION\`
          - **Chain Spec Builder**: \`staging-chain-spec-builder@$CHAIN_SPEC_VERSION\`
          - **Omni Node**: \`polkadot-omni-node@$OMNI_NODE_VERSION\`
          - **Para ID**: \`${{ env.PARA_ID }}\`
          - **Relay Chain**: \`${{ env.RELAY_CHAIN }}\`
          
          ### üõ†Ô∏è Generated Scripts
          - \`setup-rust.sh\` - Complete Rust toolchain setup with WASM support
          - \`install-chain-spec-builder.sh\` - Chain specification builder installation
          - \`install-omni-node.sh\` - Polkadot omni-node installation  
          - \`generate-chain-spec.sh\` - Chain specification generation
          - \`start-node.sh\` - Parachain node startup script
          - \`README.md\` - Comprehensive setup and troubleshooting guide
          
          ### üîß Features
          - ‚úÖ Automated version resolution from \`versions.yml\`
          - ‚úÖ Intelligent change detection (only runs when zero_to_hero versions change)
          - ‚úÖ Cross-platform compatibility (detects current architecture)
          - ‚úÖ Comprehensive error handling and validation
          - ‚úÖ Step-by-step setup instructions
          - ‚úÖ Ready-to-use development environment
          - ‚úÖ Scripts automatically committed to repository
          
          ### üíæ Repository Updates
          - Scripts automatically committed and included in this release
          - Scripts Commit: [\`${SCRIPTS_COMMIT_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/$SCRIPTS_COMMIT_SHA)
          
          EOF
          
          # Add commit history if available
          if [ "$PREVIOUS_TAG" != "v0.0.0" ]; then
            echo "### üìã Changes Since $PREVIOUS_TAG" >> $CHANGELOG_FILE
            echo "" >> $CHANGELOG_FILE
            
            # Get commits since last tag, format them nicely
            git log $PREVIOUS_TAG..HEAD --oneline --no-merges | head -20 | while read commit; do
              echo "- $commit" >> $CHANGELOG_FILE
            done
            
            echo "" >> $CHANGELOG_FILE
          fi
          
          # Add technical details
          cat >> $CHANGELOG_FILE << EOF
          ### üèóÔ∏è Build Information
          - **Workflow**: Version Change Detection ‚Üí Build Parachain ‚Üí Generate Scripts ‚Üí Commit to Repo ‚Üí Create Release
          - **Branch**: \`${{ github.ref_name }}\`
          - **Release Commit**: \`$SCRIPTS_COMMIT_SHA\`
          - **Parachain Source**: [\`${{ env.PARACHAIN_REPO }}\`](${{ env.PARACHAIN_REPO }})
          - **Version Changes**: $CHANGED_VERSIONS
          
          ### üì• Quick Start
          
          #### Option 1: Use scripts from repository (Recommended)
          1. Clone or update your repository to get the latest scripts:
             \`\`\`bash
             git clone ${{ github.server_url }}/${{ github.repository }}.git
             cd $(basename ${{ github.repository }})
             \`\`\`
          2. Navigate to the scripts directory: \`cd scripts/zero-to-hero\`
          3. Run the setup scripts in order:
             \`\`\`bash
             ./setup-rust.sh
             ./install-chain-spec-builder.sh  
             ./install-omni-node.sh
             ./generate-chain-spec.sh
             ./start-node.sh
             \`\`\`
          
          #### Option 2: Download from release
          1. Download and extract \`parachain-zero-to-hero-scripts.tar.gz\` from this release
          2. Run the setup scripts in order (same commands as above)
          
          Your parachain node will be running at \`http://localhost:9944\`
          
          ### üîó Useful Links
          - [Setup Scripts Documentation](https://github.com/${{ github.repository }}/tree/$SCRIPTS_COMMIT_SHA/scripts/zero-to-hero/README.md)
          - [Scripts Directory](https://github.com/${{ github.repository }}/tree/$SCRIPTS_COMMIT_SHA/scripts/zero-to-hero)
          - [Parachain Source Repository](${{ env.PARACHAIN_REPO }})
          - [Polkadot Documentation](https://docs.polkadot.network/)
          - [Scripts Commit](${{ github.server_url }}/${{ github.repository }}/commit/$SCRIPTS_COMMIT_SHA)
          
          ---
          
          **Full Changelog**: ${{ github.server_url }}/${{ github.repository }}/compare/$PREVIOUS_TAG...v$NEW_VERSION
          EOF
          
          echo "changelog-file=$CHANGELOG_FILE" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) ‚úÖ Changelog generated:"
          echo "üìÑ File: $CHANGELOG_FILE"
          echo "üìä Size: $(du -h $CHANGELOG_FILE | cut -f1)"

      - name: Create and push tag
        id: create-tag
        run: |
          echo "$(date -Iseconds) üè∑Ô∏è Creating and pushing tag..."
          
          NEW_VERSION="${{ steps.version-bump.outputs.new-version }}"
          TAG_NAME="v$NEW_VERSION"
          CHANGED_VERSIONS="${{ needs.check-version-changes.outputs.changed-versions }}"
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # FIXED: Create annotated tag on current HEAD (which is the scripts commit)
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME

          Automated release with parachain setup scripts.
          
          Version changes: $CHANGED_VERSIONS
          
          Component versions:
          - Rust: ${{ needs.generate-scripts.outputs.rust-version }}
          - Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}  
          - Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}
          
          Scripts included in release:
          - setup-rust.sh
          - install-chain-spec-builder.sh
          - install-omni-node.sh
          - generate-chain-spec.sh
          - start-node.sh
          - README.md
          
          Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Scripts Commit: $SCRIPTS_COMMIT_SHA
          Branch: ${{ github.ref_name }}"
          
          # Push the tag
          git push origin "$TAG_NAME"
          
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) ‚úÖ Tag created and pushed:"
          echo "üè∑Ô∏è Tag: $TAG_NAME"
          echo "üìù Tagged commit: $(git rev-parse HEAD) (includes scripts)"
          echo "üîÑ Changes: $CHANGED_VERSIONS"

      - name: Create scripts archive for release
        run: |
          echo "$(date -Iseconds) üì¶ Creating scripts archive for release..."
          
          # Verify scripts exist
          if [ ! -d "scripts/zero-to-hero" ]; then
            echo "‚ùå Scripts directory not found!"
            exit 1
          fi
          
          # Create the archive
          tar -czf parachain-zero-to-hero-scripts.tar.gz scripts/zero-to-hero/
          
          echo "‚úÖ Archive created: parachain-zero-to-hero-scripts.tar.gz"
          echo "üìä Archive size: $(du -h parachain-zero-to-hero-scripts.tar.gz | cut -f1)"
          
          # Verify archive contents
          echo "üìã Archive contents:"
          tar -tzf parachain-zero-to-hero-scripts.tar.gz

      - name: Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create-tag.outputs.tag }}
          name: "Parachain Setup Scripts ${{ steps.create-tag.outputs.tag }}"
          body_path: ${{ steps.changelog.outputs.changelog-file }}
          draft: false
          prerelease: ${{ contains(steps.version-bump.outputs.new-version, '-') }}
          files: |
            parachain-zero-to-hero-scripts.tar.gz
            scripts/zero-to-hero/setup-rust.sh
            scripts/zero-to-hero/install-chain-spec-builder.sh
            scripts/zero-to-hero/install-omni-node.sh
            scripts/zero-to-hero/generate-chain-spec.sh
            scripts/zero-to-hero/start-node.sh
            scripts/zero-to-hero/README.md

      - name: Release summary
        run: |
          echo "$(date -Iseconds) üéâ Release created successfully!"
          echo ""
          echo "üìã Release Details:"
          echo "  üè∑Ô∏è Tag: ${{ steps.create-tag.outputs.tag }}"
          echo "  üìù Type: ${{ steps.version-bump.outputs.bump-type }}"
          echo "  üîó URL: ${{ steps.create-release.outputs.html_url }}"
          echo "  üì¶ Archive: parachain-zero-to-hero-scripts.tar.gz"
          echo "  üîÑ Changes: ${{ needs.check-version-changes.outputs.changed-versions }}"
          echo "  üìù Tagged Commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
          echo ""
          echo "üì¶ Component Versions:"
          echo "  ü¶Ä Rust: ${{ needs.generate-scripts.outputs.rust-version }}"
          echo "  üîß Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
          echo "  üöÄ Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}"
          echo ""
          echo "üéØ Release includes:"
          echo "  - All setup scripts committed to repository"
          echo "  - Downloadable scripts archive (tar.gz)"
          echo "  - Individual script files"
          echo "  - Comprehensive documentation"
          echo ""
          echo "‚úÖ Scripts are available:"
          echo "  - In repository: scripts/zero-to-hero/"
          echo "  - In release: ${{ steps.create-release.outputs.html_url }}"
          echo "  - Tagged at commit: ${{ needs.generate-scripts.outputs.commit-sha }}"

  # Debug job to understand release conditions
  debug-release-conditions:
    name: Debug Release Conditions
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts]
    if: always() && needs.check-version-changes.outputs.has-changes == 'true'
    steps:
      - name: Show release conditions
        run: |
          echo "üîç Release condition check:"
          echo "  - has-changes: ${{ needs.check-version-changes.outputs.has-changes }}"
          echo "  - build-parachain result: ${{ needs.build-parachain.result }}"
          echo "  - generate-scripts result: ${{ needs.generate-scripts.result }}"
          echo "  - scripts-committed: ${{ needs.generate-scripts.outputs.scripts-committed }}"
          echo "  - event name: ${{ github.event_name }}"
          echo "  - ref: ${{ github.ref }}"
          echo "  - ref name: ${{ github.ref_name }}"
          echo "  - manual release input: ${{ github.event.inputs.create_release }}"
          echo ""
          echo "Release conditions evaluation:"
          echo "  - Auto release (push to master/dev): $([ "${{ github.event_name }}" = "push" ] && ([ "${{ github.ref }}" = "refs/heads/master" ] || [ "${{ github.ref }}" = "refs/heads/dev" ]) && echo "YES" || echo "NO")"
          echo "  - Manual release requested: $([ "${{ github.event.inputs.create_release }}" = "true" ] && echo "YES" || echo "NO")"
          echo "  - Scripts generation successful: $([ "${{ needs.generate-scripts.result }}" = "success" ] && echo "YES" || echo "NO")"
          echo "  - Scripts committed: $([ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ] && echo "YES" || echo "NO")"
          echo ""
          echo "üîÑ Will run create-release job: $([ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ] && ([ "${{ github.event_name }}" = "push" ] && ([ "${{ github.ref }}" = "refs/heads/master" ] || [ "${{ github.ref }}" = "refs/heads/dev" ]) || [ "${{ github.event.inputs.create_release }}" = "true" ]) && echo "YES" || echo "NO")"

  # Summary job that runs regardless of whether scripts were generated
  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts, create-release]
    if: always()
    steps:
      - name: Display workflow summary
        run: |
          echo "$(date -Iseconds) üìã Zero to Hero Workflow Summary"
          echo ""
          echo "üîç Version Change Check:"
          
          if [ "${{ needs.check-version-changes.outputs.has-changes }}" = "true" ]; then
            echo "  ‚úÖ Changes detected: ${{ needs.check-version-changes.outputs.changed-versions }}"
            echo "  üöÄ Scripts generation was triggered"
            echo ""
            
            # Build status
            echo "üèóÔ∏è Parachain Build:"
            case "${{ needs.build-parachain.result }}" in
              "success") echo "  ‚úÖ Build completed successfully" ;;
              "failure") echo "  ‚ùå Build failed" ;;
              "cancelled") echo "  ‚ö†Ô∏è Build was cancelled" ;;
              "skipped") echo "  ‚è≠Ô∏è Build was skipped" ;;
              *) echo "  ‚è≥ Build status: ${{ needs.build-parachain.result }}" ;;
            esac
            echo ""
            
            # Script generation status
            echo "üìú Script Generation:"
            case "${{ needs.generate-scripts.result }}" in
              "success") 
                echo "  ‚úÖ Scripts generated successfully"
                echo "  üíæ Scripts committed: ${{ needs.generate-scripts.outputs.scripts-committed }}"
                if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ]; then
                  echo "  üìù Commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
                fi
                ;;
              "failure") echo "  ‚ùå Scripts generation failed" ;;
              "cancelled") echo "  ‚ö†Ô∏è Scripts generation was cancelled" ;;
              *) echo "  ‚è≥ Scripts generation status: ${{ needs.generate-scripts.result }}" ;;
            esac
            echo ""
            
            # Release status
            echo "üöÄ Release Creation:"
            case "${{ needs.create-release.result }}" in
              "success") 
                echo "  ‚úÖ Release created successfully"
                echo "  üè∑Ô∏è Tag: ${{ needs.create-release.outputs.release-tag }}"
                echo "  üîó URL: ${{ needs.create-release.outputs.release-url }}"
                echo "  üìù Scripts included from commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
                ;;
              "failure") echo "  ‚ùå Release creation failed" ;;
              "cancelled") echo "  ‚ö†Ô∏è Release creation was cancelled" ;;
              "skipped") 
                echo "  ‚è≠Ô∏è Release creation was skipped"
                echo "  üí° Reasons for skipping:"
                if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" != "true" ]; then
                  echo "    - Scripts were not committed to repository"
                fi
                if [ "${{ github.event_name }}" != "push" ] && [ "${{ github.event.inputs.create_release }}" != "true" ]; then
                  echo "    - Not a push event and manual release not requested"
                fi
                if [ "${{ github.ref }}" != "refs/heads/master" ] && [ "${{ github.ref }}" != "refs/heads/dev" ] && [ "${{ github.event.inputs.create_release }}" != "true" ]; then
                  echo "    - Not on master/dev branch and manual release not requested"
                fi
                ;;
              *) echo "  ‚è≥ Release status: ${{ needs.create-release.result }}" ;;
            esac
            echo ""
            
            # Version information
            if [ "${{ needs.generate-scripts.result }}" = "success" ]; then
              echo "üì¶ Component Versions:"
              echo "  ü¶Ä Rust: ${{ needs.generate-scripts.outputs.rust-version }}"
              echo "  üîß Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
              echo "  üöÄ Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}"
              echo ""
            fi
            
          else
            echo "  ‚ÑπÔ∏è No zero_to_hero version changes detected"
            echo "  ‚è≠Ô∏è Scripts generation was skipped"
            echo ""
            echo "üí° To trigger script generation:"
            echo "  - Modify versions in the zero_to_hero section of .github/versions.yml"
            echo "  - Or run this workflow manually via workflow_dispatch"
            echo "  - Or use the 'force_generation' input when running manually"
          fi
          
          echo ""
          echo "üîß Workflow Information:"
          echo "  - Trigger: ${{ github.event_name }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Commit: ${{ github.sha }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "  - Manual release requested: ${{ github.event.inputs.create_release }}"
            echo "  - Force generation: ${{ github.event.inputs.force_generation }}"
          fi
          
          echo ""
          echo "üìç Next Steps:"
          if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ]; then
            echo "  ‚úÖ Scripts are available in the repository at scripts/zero-to-hero/"
            echo "  üìñ See scripts/zero-to-hero/README.md for usage instructions"
            echo "  üîó Scripts commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
          fi
          if [ "${{ needs.create-release.result }}" = "success" ]; then
            echo "  ‚úÖ Scripts are also available as release assets"
            echo "  üì• Download from: ${{ needs.create-release.outputs.release-url }}"
            echo "  üè∑Ô∏è Release tag: ${{ needs.create-release.outputs.release-tag }}"
          fi
          if [ "${{ needs.check-version-changes.outputs.has-changes }}" != "true" ]; then
            echo "  üí° No action needed - versions are up to date"
          fi